#pragma kernel PreSnycInit
#pragma kernel PreSnycUpdate

#include "UnityCG.cginc"
#include "SimplexNoise3D.cginc"

struct Firefly
{
    float3 pos;
    float3 vel;
    float4 col;
    float lifeOffset;
    float scale;
};

RWStructuredBuffer<Firefly> FireflyBuffer;\
float2 inputPos;
float deltaTime;
float time;
int randomSeed;
float stepWidth, spread;
float noiseFrequency, noiseOffset;
float shineSpeed;

// boundry setting
int4 boundBox;

// randomization from Keijiro
float Random(float u, float v)
{
    float f = dot(float2(12.9898, 78.233), float2(u, v)) + randomSeed;
    return frac(43758.5453 * sin(f)) - 0.5;
}

float3 RandomPoint(float id)
{
    float u = Random(id * 0.01334, 0.3728);
    float z = Random(0.8372, id * 0.01197);
    float l = Random(4.438, id * 0.01938 - 4.378);
    return float3(u, z, l);
}

[numthreads(256, 1, 1)]
void PreSnycInit(uint id : SV_DispatchThreadID)
{
     //scale position to fit screen
    float3 position = RandomPoint((float)id.x);
    position.x *= (boundBox.y - boundBox.x);
    position.y *= (boundBox.w - boundBox.z);
    FireflyBuffer[id.x].pos = position;
    FireflyBuffer[id.x].col = float4(1, 1, 1, 1);
    FireflyBuffer[id.x].vel = float3(0, 0, 0);
    FireflyBuffer[id.x].lifeOffset = (Random(id.x, id.x + 0.1) + 0.5) * 10; // shift life
    FireflyBuffer[id.x].scale = 1;
}

[numthreads(256, 1, 1)]
void PreSnycUpdate(uint id : SV_DispatchThreadID) 
{
    float3 p = FireflyBuffer[id.x].pos; // origin position 
    float3 seed = abs(p)+ float3(time, time, time); // prevent 0 velocity which will stuck particles
    // divergence-free noise field
    float4 sn1 = snoise(seed * noiseFrequency);
    float4 sn2 = snoise(noiseOffset - seed * noiseFrequency);
    // change speed
    float3 randForce = normalize(cross(sn1.xyz, sn2.xyz)) * stepWidth;
    float3 dir = float3(inputPos, p.z) - p;
    FireflyBuffer[id.x].vel = 1 / length(dir) * randForce + randForce;
    // set boundry
    if (p.x > boundBox.x && p.x < boundBox.y && p.y > boundBox.z && p.y < boundBox.w)
        FireflyBuffer[id.x].pos += FireflyBuffer[id.x].vel * deltaTime;
    else if (p.x <= boundBox.x)
        FireflyBuffer[id.x].pos.x += stepWidth * 2;
    else if (p.x >= boundBox.y)
        FireflyBuffer[id.x].pos.x -= stepWidth * 2;
    else if (p.y <= boundBox.z)
        FireflyBuffer[id.x].pos.y += stepWidth * 2;
    else if (p.y >= boundBox.w)
        FireflyBuffer[id.x].pos.y -= stepWidth * 2;
}