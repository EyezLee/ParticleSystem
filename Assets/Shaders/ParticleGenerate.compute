// each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateParticle

// particle data structure
struct Particle
{
    float3 position;
    float3 velocity;
    float lifetime;
};

// Particle data buffer
RWStructuredBuffer<Particle> particleBuffer;

// variables passed from CPU
float deltaTime;
float2 mousePos;

// random function
uint rng_state;
uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

// allocate workspace(x, y, z)
[numthreads(256, 1, 1)]
// data process
void UpdateParticle(uint3 id : SV_DispatchThreadID)
{
    particleBuffer[id.x].lifetime-= deltaTime;
    float3 distance = float3(mousePos.xy, 3) - particleBuffer[id.x].position;
    float3 dir = normalize(distance);

    particleBuffer[id.x].velocity += dir;
    particleBuffer[id.x].position += particleBuffer[id.x].velocity * deltaTime;

    if(particleBuffer[id.x].lifetime< 0)
    {
        rng_state = id.x;
    	float posX = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
		float posY = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
		float posZ = float(rand_xorshift()) * (1.0 / 4294967296.0) - 0.5;
		float3 normalizedPos = normalize(float3(posX, posY, posZ)) * 0.8f;
		normalizedPos *= float(rand_xorshift()) * (1.0 / 4294967296.0);  

        particleBuffer[id.x].position = float3(normalizedPos.x + mousePos.x, normalizedPos.y + mousePos.y, normalizedPos.z + 3.0);

        particleBuffer[id.x].lifetime= 4;
		particleBuffer[id.x].velocity = float3(0, 0,0);
    }
}